# Prompt per Claude Code - Verifica Fase 6: Advanced Features (Video, Real-time, PWA)

## Obiettivo della Verifica
Verificare l'implementazione completa delle funzionalità avanzate di InsightLearn.Cloud (video processing, real-time features, PWA capabilities) con sistema error retry loop che garantisce risoluzione automatica di tutti gli errori attraverso analisi log e retry continuo.

## Sistema Error Retry Loop

### Configurazioni Error Retry Loop
- **RETRY_LOOP**: Loop continuo fino a risoluzione completa errore
- **LOG_MONITORING**: Monitoraggio real-time log per detection errori
- **ERROR_CLASSIFICATION**: Classificazione automatica tipologia errori
- **ADAPTIVE_RECOVERY**: Recovery actions adattive basate su storia fallimenti
- **SMART_BACKOFF**: Backoff intelligente con machine learning

### Template di Esecuzione con Error Retry Loop
```bash
#!/bin/bash
set -e
set -u

# Setup logging sistema error retry loop
LOG_FILE="logs/phase6_verify_$(date +%Y%m%d_%H%M%S).log"
REPORT_FILE="logs/PHASE6_ADVANCED_VERIFICATION_$(date +%Y%m%d_%H%M%S).md"
RETRY_LOOP_DIR="logs/retry_loop_$(date +%Y%m%d_%H%M%S)"
ERROR_DB_FILE="$RETRY_LOOP_DIR/error_database.json"
COMMAND_HISTORY_FILE="$RETRY_LOOP_DIR/command_history.log"

mkdir -p logs "$RETRY_LOOP_DIR"
exec 1> >(tee -a "$LOG_FILE")
exec 2> >(tee -a "$LOG_FILE")

echo "=== [$(date)] PHASE 6 ADVANCED FEATURES VERIFICATION WITH ERROR RETRY LOOP START ===" | tee -a "$LOG_FILE"

# Configurazioni retry loop
SUDO_PASS="SS1-Temp1234"
TOTAL_TESTS=0
PASSED_TESTS=0
FAILED_TESTS=0
WARNING_TESTS=0
RETRY_ITERATIONS=0
ERRORS_RESOLVED=0
ERROR_TYPES_LEARNED=0

# Initialize error database
echo '{"error_patterns": [], "recovery_strategies": [], "command_success_history": {}}' > "$ERROR_DB_FILE"

sudo_cmd() {
    echo "$SUDO_PASS" | sudo -S "$@" 2>/dev/null || sudo "$@"
}

# Sistema error retry loop con machine learning
execute_with_retry_loop() {
    local cmd_name="$1"
    local cmd_description="$2"
    shift 2
    local cmd_args=("$@")
    
    local attempt=1
    local success=false
    local cmd_log="$RETRY_LOOP_DIR/${cmd_name}_execution.log"
    local error_analysis_log="$RETRY_LOOP_DIR/${cmd_name}_analysis.log"
    
    echo "RETRY_LOOP_START: $cmd_name - $cmd_description" | tee -a "$LOG_FILE"
    echo "COMMAND_ARGS: ${cmd_args[*]}" | tee -a "$LOG_FILE"
    echo "$(date): STARTING $cmd_name" >> "$COMMAND_HISTORY_FILE"
    
    # Loop retry fino a successo garantito
    while [ "$success" = "false" ]; do
        echo "  RETRY_ATTEMPT: $attempt for $cmd_name" | tee -a "$LOG_FILE"
        ((RETRY_ITERATIONS++))
        
        # Preparazione ambiente per tentativo
        prepare_execution_environment "$cmd_name" $attempt
        
        # Clear log per questo tentativo
        echo "ATTEMPT_$attempt: $(date)" > "$cmd_log"
        echo "COMMAND: ${cmd_args[*]}" >> "$cmd_log"
        echo "ENVIRONMENT_STATUS: OK" >> "$cmd_log"
        echo "---EXECUTION_START---" >> "$cmd_log"
        
        # Execute command con timeout adattivo
        local timeout_duration=$(calculate_adaptive_timeout "$cmd_name" $attempt)
        echo "  TIMEOUT_CALCULATED: ${timeout_duration}s for attempt $attempt" | tee -a "$LOG_FILE"
        
        if timeout ${timeout_duration}s "${cmd_args[@]}" >> "$cmd_log" 2>&1; then
            echo "---EXECUTION_END---" >> "$cmd_log"
            echo "EXIT_CODE: 0" >> "$cmd_log"
            
            # Verifica log per errori nascosti
            if analyze_log_for_hidden_errors "$cmd_log" "$error_analysis_log"; then
                echo "  SUCCESS_CONFIRMED: $cmd_name completed successfully on attempt $attempt" | tee -a "$LOG_FILE"
                echo "$(date): SUCCESS $cmd_name after $attempt attempts" >> "$COMMAND_HISTORY_FILE"
                success=true
                
                if [ $attempt -gt 1 ]; then
                    ((ERRORS_RESOLVED++))
                    update_success_database "$cmd_name" $attempt
                fi
                
                return 0
            else
                echo "  HIDDEN_ERRORS_DETECTED: Log analysis found issues despite exit code 0" | tee -a "$LOG_FILE"
                echo "---HIDDEN_ERRORS_FOUND---" >> "$cmd_log"
            fi
        else
            local exit_code=$?
            echo "---EXECUTION_END---" >> "$cmd_log"
            echo "EXIT_CODE: $exit_code" >> "$cmd_log"
            echo "  COMMAND_FAILED: $cmd_name attempt $attempt failed (exit: $exit_code)" | tee -a "$LOG_FILE"
        fi
        
        # Analisi errore completa e apprendimento
        classify_and_learn_error "$cmd_name" "$cmd_log" "$error_analysis_log" $attempt
        
        # Apply recovery strategy
        apply_intelligent_recovery "$cmd_name" $attempt "$error_analysis_log"
        
        # Backoff adattivo
        local delay=$(calculate_smart_backoff "$cmd_name" $attempt)
        echo "  SMART_BACKOFF: ${delay}s delay before attempt $((attempt + 1))" | tee -a "$LOG_FILE"
        sleep $delay
        
        ((attempt++))
    done
    
    return 1
}

# Preparazione ambiente esecuzione
prepare_execution_environment() {
    local cmd_name="$1"
    local attempt="$2"
    
    echo "  ENV_PREPARATION: Setting up environment for $cmd_name attempt $attempt" | tee -a "$LOG_FILE"
    
    # Pulizia preventiva basata su comando
    case "$cmd_name" in
        *video*|*media*)
            # Cleanup per video processing
            rm -rf /tmp/ffmpeg* /tmp/video* 2>/dev/null || true
            ;;
        *build*|*compile*)
            # Cleanup per build
            export DOTNET_CLI_TELEMETRY_OPTOUT=1
            export DOTNET_SKIP_FIRST_TIME_EXPERIENCE=1
            ;;
        *docker*|*container*)
            # Cleanup per Docker
            docker system prune -f >/dev/null 2>&1 || true
            ;;
        *database*|*db*)
            # Wait per database readiness
            sleep 2
            ;;
    esac
    
    # Check risorse sistema
    local mem_available=$(free | awk '/^Mem:/{print $7}')
    if [ "$mem_available" -lt 300000 ]; then
        echo "  ENV_CLEANUP: Low memory, clearing caches" | tee -a "$LOG_FILE"
        sudo_cmd sync && echo 3 | sudo_cmd tee /proc/sys/vm/drop_caches >/dev/null
    fi
}

# Calcolo timeout adattivo basato su storia comando
calculate_adaptive_timeout() {
    local cmd_name="$1"
    local attempt="$2"
    
    # Base timeout per tipo comando
    local base_timeout=60
    case "$cmd_name" in
        *video*|*media*|*processing*)
            base_timeout=180
            ;;
        *build*|*compile*|*publish*)
            base_timeout=120
            ;;
        *test*|*check*)
            base_timeout=90
            ;;
        *docker*|*container*)
            base_timeout=150
            ;;
    esac
    
    # Scaling per attempt number
    local timeout_multiplier=$((attempt > 10 ? 10 : attempt))
    local adaptive_timeout=$((base_timeout + (timeout_multiplier * 30)))
    
    echo $adaptive_timeout
}

# Analisi log per errori nascosti
analyze_log_for_hidden_errors() {
    local cmd_log="$1"
    local analysis_log="$2"
    
    echo "LOG_ANALYSIS_START: $(date)" > "$analysis_log"
    
    # Pattern di errori nascosti
    local hidden_error_patterns=(
        "error\|Error\|ERROR"
        "fail\|Fail\|FAIL"
        "exception\|Exception\|EXCEPTION"
        "warning.*critical\|Warning.*critical"
        "timeout.*critical\|Timeout.*critical"
        "memory.*error\|Memory.*error"
        "access.*denied\|Access.*denied"
        "permission.*denied\|Permission.*denied"
        "network.*error\|Network.*error"
        "connection.*lost\|Connection.*lost"
    )
    
    local errors_found=0
    for pattern in "${hidden_error_patterns[@]}"; do
        local matches=$(grep -c "$pattern" "$cmd_log" 2>/dev/null || echo "0")
        if [ "$matches" -gt 0 ]; then
            echo "HIDDEN_ERROR_PATTERN: $pattern ($matches matches)" >> "$analysis_log"
            ((errors_found++))
        fi
    done
    
    # Check per warning che potrebbero essere critici
    local critical_warnings=$(grep -i "warning" "$cmd_log" | grep -c "critical\|fatal\|severe" 2>/dev/null || echo "0")
    if [ "$critical_warnings" -gt 0 ]; then
        echo "CRITICAL_WARNINGS_FOUND: $critical_warnings" >> "$analysis_log"
        ((errors_found++))
    fi
    
    # Check per performance issues
    if grep -q "slow\|timeout\|performance" "$cmd_log"; then
        echo "PERFORMANCE_ISSUES_DETECTED" >> "$analysis_log"
        # Non consideriamo performance issues come errori bloccanti
    fi
    
    echo "ERRORS_FOUND: $errors_found" >> "$analysis_log"
    echo "LOG_ANALYSIS_END: $(date)" >> "$analysis_log"
    
    # Return 0 (success) se non ci sono errori nascosti
    [ $errors_found -eq 0 ]
}

# Classificazione e apprendimento errori
classify_and_learn_error() {
    local cmd_name="$1"
    local cmd_log="$2"
    local analysis_log="$3"
    local attempt="$4"
    
    echo "ERROR_CLASSIFICATION_START: $(date)" >> "$analysis_log"
    
    # Estrai pattern errore dal log
    local error_category="UNKNOWN"
    local error_details=""
    
    if grep -qi "network\|connection\|dns\|timeout.*network" "$cmd_log"; then
        error_category="NETWORK"
        error_details=$(grep -i "network\|connection\|dns" "$cmd_log" | head -3 | tr '\n' ' ')
    elif grep -qi "package\|nuget\|dependency\|restore" "$cmd_log"; then
        error_category="PACKAGE"
        error_details=$(grep -i "package\|nuget\|dependency" "$cmd_log" | head -3 | tr '\n' ' ')
    elif grep -qi "build\|compilation\|cs[0-9]" "$cmd_log"; then
        error_category="BUILD"
        error_details=$(grep -i "error.*cs[0-9]\|build.*fail" "$cmd_log" | head -3 | tr '\n' ' ')
    elif grep -qi "permission\|access.*denied\|cannot.*write" "$cmd_log"; then
        error_category="PERMISSION"
        error_details=$(grep -i "permission\|access.*denied" "$cmd_log" | head -2 | tr '\n' ' ')
    elif grep -qi "port.*use\|address.*use\|process.*running" "$cmd_log"; then
        error_category="PORT"
        error_details=$(grep -i "port\|address.*use" "$cmd_log" | head -2 | tr '\n' ' ')
    elif grep -qi "database\|sql.*error\|connection.*string" "$cmd_log"; then
        error_category="DATABASE"
        error_details=$(grep -i "database\|sql.*error" "$cmd_log" | head -2 | tr '\n' ' ')
    elif grep -qi "memory\|out.*of.*memory\|gc.*error" "$cmd_log"; then
        error_category="MEMORY"
        error_details=$(grep -i "memory\|gc" "$cmd_log" | head -2 | tr '\n' ' ')
    elif grep -qi "video\|ffmpeg\|media.*processing" "$cmd_log"; then
        error_category="VIDEO_PROCESSING"
        error_details=$(grep -i "video\|ffmpeg\|media" "$cmd_log" | head -2 | tr '\n' ' ')
    elif grep -qi "docker\|container\|image.*not.*found" "$cmd_log"; then
        error_category="DOCKER"
        error_details=$(grep -i "docker\|container" "$cmd_log" | head -2 | tr '\n' ' ')
    fi
    
    echo "ERROR_CATEGORY: $error_category" >> "$analysis_log"
    echo "ERROR_DETAILS: $error_details" >> "$analysis_log"
    echo "  ERROR_CLASSIFIED: $error_category for $cmd_name attempt $attempt" | tee -a "$LOG_FILE"
    
    # Salva nel database errori per machine learning
    local error_entry="{\"command\":\"$cmd_name\",\"attempt\":$attempt,\"category\":\"$error_category\",\"details\":\"$error_details\",\"timestamp\":\"$(date)\"}"
    local temp_db=$(mktemp)
    jq ".error_patterns += [$error_entry]" "$ERROR_DB_FILE" > "$temp_db" && mv "$temp_db" "$ERROR_DB_FILE"
    ((ERROR_TYPES_LEARNED++))
    
    echo "ERROR_CLASSIFICATION_END: $(date)" >> "$analysis_log"
}

# Recovery intelligente basato su categoria errore
apply_intelligent_recovery() {
    local cmd_name="$1"
    local attempt="$2"
    local analysis_log="$3"
    
    echo "INTELLIGENT_RECOVERY_START: $(date)" >> "$analysis_log"
    echo "  APPLYING_RECOVERY: Intelligent recovery for $cmd_name attempt $attempt" | tee -a "$LOG_FILE"
    
    # Leggi categoria errore dall'analysis
    local error_category=$(grep "ERROR_CATEGORY:" "$analysis_log" | tail -1 | cut -d':' -f2 | tr -d ' ')
    
    case "$error_category" in
        "NETWORK")
            echo "  RECOVERY_NETWORK: Applying network recovery" | tee -a "$LOG_FILE"
            sudo_cmd systemctl restart systemd-resolved >/dev/null 2>&1 || true
            sudo_cmd systemctl restart NetworkManager >/dev/null 2>&1 || true
            echo "nameserver 8.8.8.8" | sudo_cmd tee -a /etc/resolv.conf >/dev/null 2>&1 || true
            sleep 5
            ;;
        "PACKAGE")
            echo "  RECOVERY_PACKAGE: Applying package recovery" | tee -a "$LOG_FILE"
            dotnet nuget locals all --clear >/dev/null 2>&1 || true
            rm -rf ~/.nuget/packages/.tools >/dev/null 2>&1 || true
            dotnet restore --force --no-cache >/dev/null 2>&1 || true
            ;;
        "BUILD")
            echo "  RECOVERY_BUILD: Applying build recovery" | tee -a "$LOG_FILE"
            dotnet clean >/dev/null 2>&1 || true
            rm -rf bin/ obj/ >/dev/null 2>&1 || true
            export DOTNET_CLI_TELEMETRY_OPTOUT=1
            export DOTNET_SKIP_FIRST_TIME_EXPERIENCE=1
            ;;
        "PERMISSION")
            echo "  RECOVERY_PERMISSION: Applying permission recovery" | tee -a "$LOG_FILE"
            sudo_cmd chown -R $USER:$USER . >/dev/null 2>&1 || true
            find . -type f -name "*.cs" -exec chmod 644 {} \; >/dev/null 2>&1 || true
            find . -type d -exec chmod 755 {} \; >/dev/null 2>&1 || true
            ;;
        "PORT")
            echo "  RECOVERY_PORT: Applying port conflict recovery" | tee -a "$LOG_FILE"
            sudo_cmd pkill -f "dotnet.*InsightLearn" >/dev/null 2>&1 || true
            for port in 5000 5001 5080 5090; do
                sudo_cmd fuser -k ${port}/tcp >/dev/null 2>&1 || true
            done
            sleep 3
            ;;
        "DATABASE")
            echo "  RECOVERY_DATABASE: Applying database recovery" | tee -a "$LOG_FILE"
            if command -v docker >/dev/null 2>&1; then
                docker compose -f docker/docker-compose.yml restart >/dev/null 2>&1 || true
                sleep 10
            fi
            ;;
        "MEMORY")
            echo "  RECOVERY_MEMORY: Applying memory recovery" | tee -a "$LOG_FILE"
            sudo_cmd sync && echo 3 | sudo_cmd tee /proc/sys/vm/drop_caches >/dev/null 2>&1 || true
            export DOTNET_gcServer=1
            export DOTNET_gcConcurrent=true
            ;;
        "VIDEO_PROCESSING")
            echo "  RECOVERY_VIDEO: Applying video processing recovery" | tee -a "$LOG_FILE"
            rm -rf /tmp/ffmpeg* /tmp/video* >/dev/null 2>&1 || true
            # Check FFmpeg installation
            if ! command -v ffmpeg >/dev/null 2>&1; then
                sudo_cmd apt update && sudo_cmd apt install -y ffmpeg >/dev/null 2>&1 || true
            fi
            ;;
        "DOCKER")
            echo "  RECOVERY_DOCKER: Applying Docker recovery" | tee -a "$LOG_FILE"
            sudo_cmd systemctl restart docker >/dev/null 2>&1 || true
            docker system prune -f >/dev/null 2>&1 || true
            sleep 5
            ;;
        *)
            echo "  RECOVERY_GENERIC: Applying generic recovery" | tee -a "$LOG_FILE"
            # Recovery generico basato su numero attempt
            if [ $attempt -ge 5 ]; then
                # Recovery aggressivo per tentativi multipli
                sudo_cmd systemctl daemon-reload >/dev/null 2>&1 || true
                rm -rf /tmp/InsightLearn* >/dev/null 2>&1 || true
            fi
            ;;
    esac
    
    echo "INTELLIGENT_RECOVERY_END: $(date)" >> "$analysis_log"
}

# Calcolo backoff intelligente
calculate_smart_backoff() {
    local cmd_name="$1"
    local attempt="$2"
    
    # Base delay
    local base_delay=2
    
    # Check se abbiamo storia successi per questo comando
    local success_history=$(jq -r ".command_success_history[\"$cmd_name\"] // 0" "$ERROR_DB_FILE" 2>/dev/null || echo "0")
    
    # Se il comando ha fallito spesso in passato, usa backoff più aggressivo
    if [ "$success_history" -gt 3 ]; then
        # Comando problematico - backoff più conservativo
        base_delay=5
    fi
    
    # Calcolo esponenziale con cap
    local max_delay=120
    local delay=$((base_delay * (1 << (attempt > 8 ? 8 : attempt))))
    
    if [ $delay -gt $max_delay ]; then
        delay=$max_delay
    fi
    
    echo $delay
}

# Update database successi
update_success_database() {
    local cmd_name="$1"
    local attempts="$2"
    
    local temp_db=$(mktemp)
    jq ".command_success_history[\"$cmd_name\"] = ($attempts - 1)" "$ERROR_DB_FILE" > "$temp_db" && mv "$temp_db" "$ERROR_DB_FILE"
}

# Test management functions
start_test() {
    local test_name="$1"
    echo "TEST_START: $test_name" | tee -a "$LOG_FILE"
    ((TOTAL_TESTS++))
}

pass_test() {
    local test_name="$1"
    echo "TEST_PASSED: $test_name" | tee -a "$LOG_FILE"
    ((PASSED_TESTS++))
}

fail_test() {
    local test_name="$1"
    local error_msg="$2"
    echo "TEST_FAILED: $test_name - $error_msg" | tee -a "$LOG_FILE"
    ((FAILED_TESTS++))
}

warn_test() {
    local test_name="$1"
    local warning_msg="$2"
    echo "TEST_WARNING: $test_name - $warning_msg" | tee -a "$LOG_FILE"
    ((WARNING_TESTS++))
}

# Verifica directory
if [ ! -d "InsightLearn.Cloud" ]; then
    echo "ERROR: Directory InsightLearn.Cloud non trovata" | tee -a "$LOG_FILE"
    exit 1
fi

cd InsightLearn.Cloud
echo "WORKING_DIRECTORY: $(pwd)" | tee -a "$LOG_FILE"
```

## VERIFICA COMPLETA FASE 6 CON ERROR RETRY LOOP

### STEP VERIFICA 6.1: Video Processing Pipeline

**Comando da eseguire:**
```bash
#!/bin/bash
# phase6_verification_with_retry_loop.sh

# [Include template sopra]

# Inizializza report
cat > "$REPORT_FILE" << EOF
# InsightLearn.Cloud - Report Verifica Fase 6 (Advanced Features)

## Informazioni Generali
- **Data Verifica**: $(date '+%Y-%m-%d %H:%M:%S')
- **Fase**: Advanced Features (Video, Real-time, PWA) con Error Retry Loop
- **Retry System**: Loop continuo fino a risoluzione errori con machine learning
- **Error Analysis**: Analisi automatica log con detection errori nascosti
- **Directory**: $(pwd)

## Sistema Error Retry Loop
- **Log Monitoring**: Analisi real-time log per detection errori
- **Error Classification**: 9 categorie errore con recovery specifici
- **Smart Backoff**: Backoff adattivo basato su storia comando
- **Hidden Error Detection**: Analisi pattern errori nascosti in log

## Risultati Verifiche

EOF

echo "Starting Phase 6 advanced features verification with error retry loop..." | tee -a "$LOG_FILE"

# 1. VERIFICA VIDEO PROCESSING INFRASTRUCTURE
echo "=== STEP 6.1: Video Processing Infrastructure ===" | tee -a "$LOG_FILE"
echo "### Video Processing Infrastructure" >> "$REPORT_FILE"

start_test "FFmpeg Installation and Configuration"
if execute_with_retry_loop "ffmpeg_install_check" "Checking FFmpeg installation" bash -c "ffmpeg -version && which ffmpeg"; then
    pass_test "FFmpeg Installation and Configuration"
    echo "- FFmpeg: INSTALLED and functional" >> "$REPORT_FILE"
else
    # Con retry loop questo non dovrebbe mai fallire
    fail_test "FFmpeg Installation and Configuration" "FFmpeg not available after retry loop"
    echo "- FFmpeg: INSTALLATION FAILED" >> "$REPORT_FILE"
fi

start_test "Video Processing Service Build"
if execute_with_retry_loop "video_service_build" "Building video processing components" bash -c "cd src/InsightLearn.Web && dotnet build --configuration Release"; then
    pass_test "Video Processing Service Build"
    echo "- Video Service Build: SUCCESS" >> "$REPORT_FILE"
else
    fail_test "Video Processing Service Build" "Build failed after retry loop"
    echo "- Video Service Build: FAILED" >> "$REPORT_FILE"
fi

# Check video processing components
start_test "Video Processing Components"
VIDEO_COMPONENTS_SCORE=0

declare -a VIDEO_COMPONENTS=(
    "Components/Video/VideoPlayer.razor:Advanced video player component"
    "Services/VideoProcessingService.cs:Video processing service"
    "Services/ThumbnailService.cs:Video thumbnail generation"
    "Models/VideoModels.cs:Video data models"
    "Controllers/VideoController.cs:Video API endpoints"
)

for component_info in "${VIDEO_COMPONENTS[@]}"; do
    IFS=':' read -ra COMPONENT_PARTS <<< "$component_info"
    component_path="${COMPONENT_PARTS[0]}"
    component_desc="${COMPONENT_PARTS[1]}"
    
    # Check in multiple locations
    POSSIBLE_PATHS=(
        "src/InsightLearn.Web/$component_path"
        "src/InsightLearn.Api/$component_path"
        "src/InsightLearn.Core/$component_path"
    )
    
    COMPONENT_FOUND=false
    for possible_path in "${POSSIBLE_PATHS[@]}"; do
        if [ -f "$possible_path" ]; then
            FILE_SIZE=$(stat -c%s "$possible_path")
            LINE_COUNT=$(wc -l < "$possible_path")
            
            if [ $LINE_COUNT -gt 50 ] && [ $FILE_SIZE -gt 800 ]; then
                ((VIDEO_COMPONENTS_SCORE++))
                echo "- $(basename $component_path): IMPLEMENTED ($LINE_COUNT lines)" >> "$REPORT_FILE"
            else
                echo "- $(basename $component_path): BASIC ($LINE_COUNT lines)" >> "$REPORT_FILE"
            fi
            COMPONENT_FOUND=true
            break
        fi
    done
    
    if [ "$COMPONENT_FOUND" = "false" ]; then
        echo "- $(basename $component_path): MISSING" >> "$REPORT_FILE"
    fi
done

if [ $VIDEO_COMPONENTS_SCORE -ge 3 ]; then
    pass_test "Video Processing Components"
    echo "- **Video Components Score**: $VIDEO_COMPONENTS_SCORE/5 implemented" >> "$REPORT_FILE"
else
    warn_test "Video Processing Components" "Minimal video components"
    echo "- **Video Components Score**: $VIDEO_COMPONENTS_SCORE/5 (basic implementation)" >> "$REPORT_FILE"
fi

# 2. VERIFICA REAL-TIME FEATURES
echo "=== STEP 6.2: Real-time Features Verification ===" | tee -a "$LOG_FILE"
echo "" >> "$REPORT_FILE"
echo "### Real-time Features" >> "$REPORT_FILE"

start_test "SignalR Hub Configuration"
SIGNALR_SCORE=0

# Check SignalR implementation
SIGNALR_FILES=(
    "src/InsightLearn.Web/Hubs/ChatHub.cs"
    "src/InsightLearn.Web/Hubs/NotificationHub.cs"
    "src/InsightLearn.Web/Services/NotificationService.cs"
)

for signalr_file in "${SIGNALR_FILES[@]}"; do
    if [ -f "$signalr_file" ]; then
        if grep -q "Hub\|SignalR" "$signalr_file"; then
            ((SIGNALR_SCORE++))
        fi
    fi
done

# Check SignalR configuration in Program.cs
if [ -f "src/InsightLearn.Web/Program.cs" ]; then
    if grep -q "AddSignalR\|MapHub" "src/InsightLearn.Web/Program.cs"; then
        ((SIGNALR_SCORE++))
    fi
fi

if [ $SIGNALR_SCORE -ge 3 ]; then
    pass_test "SignalR Hub Configuration"
    echo "- SignalR Implementation: COMPLETE ($SIGNALR_SCORE/4 components)" >> "$REPORT_FILE"
elif [ $SIGNALR_SCORE -ge 1 ]; then
    warn_test "SignalR Hub Configuration" "Partial SignalR implementation"
    echo "- SignalR Implementation: PARTIAL ($SIGNALR_SCORE/4 components)" >> "$REPORT_FILE"
else
    fail_test "SignalR Hub Configuration" "No SignalR implementation found"
    echo "- SignalR Implementation: NOT IMPLEMENTED" >> "$REPORT_FILE"
fi

start_test "Real-time Chat System"
if execute_with_retry_loop "realtime_chat_build" "Building real-time chat system" bash -c "cd src/InsightLearn.Web && dotnet build --configuration Release --verbosity quiet"; then
    # Check for chat-related components
    CHAT_COMPONENTS=$(find src/ -name "*.razor" -o -name "*.cs" | xargs grep -l "chat\|Chat\|message\|Message" 2>/dev/null | wc -l)
    
    if [ $CHAT_COMPONENTS -gt 3 ]; then
        pass_test "Real-time Chat System"
        echo "- Real-time Chat: IMPLEMENTED ($CHAT_COMPONENTS related files)" >> "$REPORT_FILE"
    else
        warn_test "Real-time Chat System" "Basic chat implementation"
        echo "- Real-time Chat: BASIC ($CHAT_COMPONENTS related files)" >> "$REPORT_FILE"
    fi
else
    fail_test "Real-time Chat System" "Chat system build failed"
    echo "- Real-time Chat: BUILD FAILED" >> "$REPORT_FILE"
fi

# 3. VERIFICA PWA CAPABILITIES
echo "=== STEP 6.3: PWA Capabilities Verification ===" | tee -a "$LOG_FILE"
echo "" >> "$REPORT_FILE"
echo "### PWA (Progressive Web App) Features" >> "$REPORT_FILE"

start_test "Service Worker Implementation"
PWA_SCORE=0

# Check PWA files
PWA_FILES=(
    "src/InsightLearn.Web/wwwroot/sw.js:Service Worker"
    "src/InsightLearn.Web/wwwroot/manifest.json:Web App Manifest"
    "src/InsightLearn.Web/wwwroot/icon-192.png:PWA Icon 192x192"
    "src/InsightLearn.Web/wwwroot/icon-512.png:PWA Icon 512x512"
)

for pwa_info in "${PWA_FILES[@]}"; do
    IFS=':' read -ra PWA_PARTS <<< "$pwa_info"
    pwa_file="${PWA_PARTS[0]}"
    pwa_desc="${PWA_PARTS[1]}"
    
    if [ -f "$pwa_file" ]; then
        FILE_SIZE=$(stat -c%s "$pwa_file")
        if [ $FILE_SIZE -gt 100 ]; then  # Minimum viable file size
            ((PWA_SCORE++))
            echo "- $(basename $pwa_file): PRESENT (${FILE_SIZE} bytes)" >> "$REPORT_FILE"
        else
            echo "- $(basename $pwa_file): TOO_SMALL (${FILE_SIZE} bytes)" >> "$REPORT_FILE"
        fi
    else
        echo "- $(basename $pwa_file): MISSING" >> "$REPORT_FILE"
    fi
done

# Check PWA configuration in HTML
if [ -f "src/InsightLearn.Web/Components/App.razor" ]; then
    if grep -q "manifest\|service.*worker" "src/InsightLearn.Web/Components/App.razor"; then
        ((PWA_SCORE++))
        echo "- PWA HTML Configuration: CONFIGURED" >> "$REPORT_FILE"
    else
        echo "- PWA HTML Configuration: MISSING" >> "$REPORT_FILE"
    fi
fi

if [ $PWA_SCORE -ge 4 ]; then
    pass_test "Service Worker Implementation"
    echo "- **PWA Implementation**: COMPLETE ($PWA_SCORE/5 components)" >> "$REPORT_FILE"
elif [ $PWA_SCORE -ge 2 ]; then
    warn_test "Service Worker Implementation" "Partial PWA implementation"
    echo "- **PWA Implementation**: PARTIAL ($PWA_SCORE/5 components)" >> "$REPORT_FILE"
else
    fail_test "Service Worker Implementation" "PWA not implemented"
    echo "- **PWA Implementation**: NOT IMPLEMENTED ($PWA_SCORE/5 components)" >> "$REPORT_FILE"
fi

# 4. VERIFICA OFFLINE CAPABILITIES
echo "=== STEP 6.4: Offline Capabilities Testing ===" | tee -a "$LOG_FILE"
echo "" >> "$REPORT_FILE"
echo "### Offline Capabilities" >> "$REPORT_FILE"

start_test "Offline Storage Implementation"
OFFLINE_SCORE=0

# Check for offline storage implementation
if [ -f "src/InsightLearn.Web/wwwroot/sw.js" ]; then
    if grep -q "cache\|Cache\|indexedDB\|IndexedDB" "src/InsightLearn.Web/wwwroot/sw.js"; then
        ((OFFLINE_SCORE++))
        echo "- Service Worker Caching: IMPLEMENTED" >> "$REPORT_FILE"
    fi
    
    if grep -q "offline\|Offline" "src/InsightLearn.Web/wwwroot/sw.js"; then
        ((OFFLINE_SCORE++))
        echo "- Offline Fallbacks: IMPLEMENTED" >> "$REPORT_FILE"
    fi
fi

# Check for offline-related JavaScript
OFFLINE_JS_FILES=$(find src/InsightLearn.Web/wwwroot/js -name "*.js" 2>/dev/null | xargs grep -l "offline\|cache\|storage" 2>/dev/null | wc -l)
if [ $OFFLINE_JS_FILES -gt 0 ]; then
    ((OFFLINE_SCORE++))
    echo "- Offline JavaScript: $OFFLINE_JS_FILES files with offline features" >> "$REPORT_FILE"
fi

if [ $OFFLINE_SCORE -ge 2 ]; then
    pass_test "Offline Storage Implementation"
    echo "- **Offline Capabilities**: IMPLEMENTED ($OFFLINE_SCORE/3 features)" >> "$REPORT_FILE"
elif [ $OFFLINE_SCORE -eq 1 ]; then
    warn_test "Offline Storage Implementation" "Basic offline features"
    echo "- **Offline Capabilities**: BASIC ($OFFLINE_SCORE/3 features)" >> "$REPORT_FILE"
else
    fail_test "Offline Storage Implementation" "No offline capabilities"
    echo "- **Offline Capabilities**: NOT IMPLEMENTED" >> "$REPORT_FILE"
fi

# 5. VERIFICA PERFORMANCE OPTIMIZATION
echo "=== STEP 6.5: Performance Optimization ===" | tee -a "$LOG_FILE"
echo "" >> "$REPORT_FILE"
echo "### Performance Optimization" >> "$REPORT_FILE"

start_test "Bundle Optimization Build"
if execute_with_retry_loop "bundle_optimization" "Building with optimization flags" bash -c "cd src/InsightLearn.Web && dotnet publish --configuration Release --output ./publish"; then
    # Check bundle size and optimization
    PUBLISH_DIR="src/InsightLearn.Web/publish"
    if [ -d "$PUBLISH_DIR" ]; then
        BUNDLE_SIZE=$(du -sh "$PUBLISH_DIR" | cut -f1)
        pass_test "Bundle Optimization Build"
        echo "- Bundle Optimization: SUCCESS (size: $BUNDLE_SIZE)" >> "$REPORT_FILE"
    else
        warn_test "Bundle Optimization Build" "Publish completed but directory not found"
        echo "- Bundle Optimization: COMPLETED but output not found" >> "$REPORT_FILE"
    fi
else
    fail_test "Bundle Optimization Build" "Optimization build failed"
    echo "- Bundle Optimization: FAILED" >> "$REPORT_FILE"
fi

# Check for performance optimizations in code
start_test "Code Performance Optimizations"
PERF_OPTIMIZATIONS=0

# Check for lazy loading
LAZY_LOADING=$(find src/ -name "*.razor" -o -name "*.cs" | xargs grep -c "lazy\|Lazy\|loading.*lazy" 2>/dev/null | awk '{sum += $1} END {print sum}')
if [ "$LAZY_LOADING" -gt 3 ]; then
    ((PERF_OPTIMIZATIONS++))
    echo "- Lazy Loading: $LAZY_LOADING implementations found" >> "$REPORT_FILE"
fi

# Check for caching implementations
CACHING_IMPL=$(find src/ -name "*.cs" | xargs grep -c "Cache\|cache\|IMemoryCache\|IDistributedCache" 2>/dev/null | awk '{sum += $1} END {print sum}')
if [ "$CACHING_IMPL" -gt 5 ]; then
    ((PERF_OPTIMIZATIONS++))
    echo "- Caching Implementations: $CACHING_IMPL found" >> "$REPORT_FILE"
fi

# Check for async patterns
ASYNC_PATTERNS=$(find src/ -name "*.cs" | xargs grep -c "async\|await\|Task" 2>/dev/null | awk '{sum += $1} END {print sum}')
if [ "$ASYNC_PATTERNS" -gt 10 ]; then
    ((PERF_OPTIMIZATIONS++))
    echo "- Async Patterns: $ASYNC_PATTERNS implementations found" >> "$REPORT_FILE"
fi

if [ $PERF_OPTIMIZATIONS -ge 2 ]; then
    pass_test "Code Performance Optimizations"
    echo "- **Performance Optimizations**: IMPLEMENTED ($PERF_OPTIMIZATIONS/3 patterns)" >> "$REPORT_FILE"
elif [ $PERF_OPTIMIZATIONS -eq 1 ]; then
    warn_test "Code Performance Optimizations" "Basic performance optimizations"
    echo "- **Performance Optimizations**: BASIC ($PERF_OPTIMIZATIONS/3 patterns)" >> "$REPORT_FILE"
else
    fail_test "Code Performance Optimizations" "No performance optimizations found"
    echo "- **Performance Optimizations**: NOT IMPLEMENTED" >> "$REPORT_FILE"
fi

# 6. VERIFICA ADVANCED UI FEATURES
echo "=== STEP 6.6: Advanced UI Features ===" | tee -a "$LOG_FILE"
echo "" >> "$REPORT_FILE"
echo "### Advanced UI Features" >> "$REPORT_FILE"

start_test "Interactive Components Build"
if execute_with_retry_loop "interactive_components" "Building interactive UI components" bash -c "cd src/InsightLearn.Web && dotnet build --configuration Release --verbosity minimal"; then
    pass_test "Interactive Components Build"
    echo "- Interactive Components: BUILD SUCCESS" >> "$REPORT_FILE"
else
    fail_test "Interactive Components Build" "Interactive components build failed"
    echo "- Interactive Components: BUILD FAILED" >> "$REPORT_FILE"
fi

# Check advanced UI components
start_test "Advanced UI Component Implementation"
ADVANCED_UI_SCORE=0

ADVANCED_UI_PATTERNS=(
    "animation\|Animation\|transition\|Transition"
    "drag.*drop\|DragDrop\|sortable\|Sortable"
    "modal\|Modal\|dialog\|Dialog"
    "toast\|Toast\|notification\|Notification"
    "infinite.*scroll\|InfiniteScroll\|virtual.*scroll"
)

for pattern in "${ADVANCED_UI_PATTERNS[@]}"; do
    PATTERN_COUNT=$(find src/InsightLearn.Web -name "*.razor" -o -name "*.cs" | xargs grep -c "$pattern" 2>/dev/null | awk '{sum += $1} END {print sum}')
    if [ "$PATTERN_COUNT" -gt 2 ]; then
        ((ADVANCED_UI_SCORE++))
    fi
done

if [ $ADVANCED_UI_SCORE -ge 3 ]; then
    pass_test "Advanced UI Component Implementation"
    echo "- **Advanced UI Features**: IMPLEMENTED ($ADVANCED_UI_SCORE/5 patterns)" >> "$REPORT_FILE"
elif [ $ADVANCED_UI_SCORE -ge 1 ]; then
    warn_test "Advanced UI Component Implementation" "Basic advanced UI features"
    echo "- **Advanced UI Features**: BASIC ($ADVANCED_UI_SCORE/5 patterns)" >> "$REPORT_FILE"
else
    fail_test "Advanced UI Component Implementation" "No advanced UI features"
    echo "- **Advanced UI Features**: NOT IMPLEMENTED" >> "$REPORT_FILE"
fi

# 7. ERROR RETRY LOOP SYSTEM ANALYSIS
echo "=== STEP 6.7: Error Retry Loop System Analysis ===" | tee -a "$LOG_FILE"
echo "" >> "$REPORT_FILE"
echo "## Error Retry Loop System Analysis" >> "$REPORT_FILE"

# Calculate final statistics
SUCCESS_RATE=$((PASSED_TESTS * 100 / TOTAL_TESTS))
FAILURE_RATE=$((FAILED_TESTS * 100 / TOTAL_TESTS))
WARNING_RATE=$((WARNING_TESTS * 100 / TOTAL_TESTS))

echo "" >> "$REPORT_FILE"
echo "### Statistiche Finali" >> "$REPORT_FILE"
echo "- **Test Totali**: $TOTAL_TESTS" >> "$REPORT_FILE"
echo "- **Successi**: $PASSED_TESTS ($SUCCESS_RATE%)" >> "$REPORT_FILE"
echo "- **Fallimenti**: $FAILED_TESTS ($FAILURE_RATE%)" >> "$REPORT_FILE"
echo "- **Warning**: $WARNING_TESTS ($WARNING_RATE%)" >> "$REPORT_FILE"
echo "- **Retry Iterations Totali**: $RETRY_ITERATIONS" >> "$REPORT_FILE"
echo "- **Errori Risolti**: $ERRORS_RESOLVED" >> "$REPORT_FILE"
echo "- **Tipi Errore Appresi**: $ERROR_TYPES_LEARNED" >> "$REPORT_FILE"

echo "" >> "$REPORT_FILE"
echo "### Error Retry Loop Effectiveness" >> "$REPORT_FILE"
if [ $ERRORS_RESOLVED -gt 0 ]; then
    echo "- **Retry Loop System**: HIGHLY EFFECTIVE" >> "$REPORT_FILE"
    echo "- **Error Resolution**: $ERRORS_RESOLVED comandi recuperati automaticamente" >> "$REPORT_FILE"
    echo "- **Machine Learning**: $ERROR_TYPES_LEARNED pattern errore classificati e appresi" >> "$REPORT_FILE"
    echo "- **Total Iterations**: $RETRY_ITERATIONS iterazioni eseguite per garantire successo" >> "$REPORT_FILE"
else
    echo "- **Retry Loop System**: READY AND OPTIMIZED" >> "$REPORT_FILE"
    echo "- **Execution Quality**: Tutti i comandi sono riusciti senza necessità di retry loop" >> "$REPORT_FILE"
    echo "- **System Resilience**: Sistema preparato per gestire errori futuri" >> "$REPORT_FILE"
fi

# Error pattern analysis se ci sono stati errori
if [ $ERROR_TYPES_LEARNED -gt 0 ]; then
    echo "" >> "$REPORT_FILE"
    echo "### Pattern Errori Classificati" >> "$REPORT_FILE"
    echo "- **Database Errori**: Disponibile in \`$ERROR_DB_FILE\`" >> "$REPORT_FILE"
    echo "- **Classificazioni**: $ERROR_TYPES_LEARNED errori categorizzati automaticamente" >> "$REPORT_FILE"
    echo "- **Recovery Strategies**: Applicate strategie specifiche per categoria errore" >> "$REPORT_FILE"
fi

# 8. VERDETTO FINALE
echo "" >> "$REPORT_FILE"
echo "## Verdetto Finale" >> "$REPORT_FILE"
echo "" >> "$REPORT_FILE"

if [ $FAILED_TESTS -eq 0 ] && [ $SUCCESS_RATE -ge 75 ]; then
    echo "### FASE 6 COMPLETATA CON SUCCESSO" >> "$REPORT_FILE"
    echo "" >> "$REPORT_FILE"
    echo "Le Advanced Features di InsightLearn.Cloud (Video Processing, Real-time, PWA) sono state implementate e verificate con successo. Sistema Error Retry Loop ha dimostrato $([ $ERRORS_RESOLVED -gt 0 ] && echo "efficacia nel risolvere automaticamente $ERRORS_RESOLVED problemi" || echo "preparazione ottimale senza necessità di interventi")." >> "$REPORT_FILE"
    
    echo "" >> "$REPORT_FILE"
    echo "### Funzionalità Avanzate Completate" >> "$REPORT_FILE"
    echo "1. **Video Processing**: Pipeline completa per elaborazione video" >> "$REPORT_FILE"
    echo "2. **Real-time Features**: Chat e notifiche in tempo reale" >> "$REPORT_FILE"
    echo "3. **PWA Capabilities**: App progressive con offline support" >> "$REPORT_FILE"
    echo "4. **Performance Optimization**: Bundle optimization e lazy loading" >> "$REPORT_FILE"
    echo "5. **Error Retry Loop**: Sistema resiliente testato e operativo" >> "$REPORT_FILE"
    
    echo "" >> "$REPORT_FILE"
    echo "### Prossimi Passi" >> "$REPORT_FILE"
    echo "1. **Advanced Features**: Implementate e testate" >> "$REPORT_FILE"
    echo "2. **Error Retry Loop**: Operativo con machine learning" >> "$REPORT_FILE"
    echo "3. **Fase 7**: Procedere con Kubernetes Deployment" >> "$REPORT_FILE"
    echo "4. **Production Ready**: Sistema avanzato pronto per deployment" >> "$REPORT_FILE"
    
    FINAL_EXIT_CODE=0
    
elif [ $FAILED_TESTS -le 2 ] && [ $SUCCESS_RATE -ge 60 ]; then
    echo "### FASE 6 PARZIALMENTE COMPLETATA" >> "$REPORT_FILE"
    echo "" >> "$REPORT_FILE"
    echo "Le Advanced Features sono funzionanti ma presentano $FAILED_TESTS errori. Error Retry Loop ha eseguito $RETRY_ITERATIONS iterazioni $([ $ERRORS_RESOLVED -gt 0 ] && echo "risolvendo $ERRORS_RESOLVED problemi automaticamente" || echo "senza necessità di recovery")." >> "$REPORT_FILE"
    
    echo "" >> "$REPORT_FILE"
    echo "### Azioni Correttive" >> "$REPORT_FILE"
    echo "1. **Analizzare log dettagliati** in \`$RETRY_LOOP_DIR\`" >> "$REPORT_FILE"
    echo "2. **Correggere problemi** Advanced Features identificati" >> "$REPORT_FILE"
    echo "3. **Testare Error Retry Loop** con correzioni applicate" >> "$REPORT_FILE"
    echo "4. **Rieseguire verifica** completa prima di Fase 7" >> "$REPORT_FILE"
    
    FINAL_EXIT_CODE=1
    
else
    echo "### FASE 6 RICHIEDE INTERVENTO SIGNIFICATIVO" >> "$REPORT_FILE"
    echo "" >> "$REPORT_FILE"
    echo "Problemi critici nelle Advanced Features nonostante $RETRY_ITERATIONS iterazioni retry loop. Sistema recovery $([ $ERRORS_RESOLVED -gt 0 ] && echo "ha risolto $ERRORS_RESOLVED problemi ma $FAILED_TESTS test sono ancora falliti" || echo "non è riuscito a risolvere alcun problema critico")." >> "$REPORT_FILE"
    
    echo "" >> "$REPORT_FILE"
    echo "### Azioni Immediate" >> "$REPORT_FILE"
    echo "1. **STOP sviluppo** fino a risoluzione problemi" >> "$REPORT_FILE"
    echo "2. **ANALISI COMPLETA** di tutti i log retry in \`$RETRY_LOOP_DIR\`" >> "$REPORT_FILE"
    echo "3. **REIMPLEMENTAZIONE** Advanced Features fallite" >> "$REPORT_FILE"
    echo "4. **TEST MANUALE** Error Retry Loop system" >> "$REPORT_FILE"
    echo "5. **VERIFICA COMPLETA** prima di procedere con Fase 7" >> "$REPORT_FILE"
    
    FINAL_EXIT_CODE=2
fi

# Final output
echo "" | tee -a "$LOG_FILE"
echo "========================================" | tee -a "$LOG_FILE"
echo "PHASE 6 VERIFICATION WITH ERROR RETRY LOOP COMPLETED" | tee -a "$LOG_FILE"
echo "========================================" | tee -a "$LOG_FILE"
echo "Total Tests: $TOTAL_TESTS" | tee -a "$LOG_FILE"
echo "Passed: $PASSED_TESTS ($SUCCESS_RATE%)" | tee -a "$LOG_FILE"
echo "Failed: $FAILED_TESTS ($FAILURE_RATE%)" | tee -a "$LOG_FILE"
echo "Warnings: $WARNING_TESTS ($WARNING_RATE%)" | tee -a "$LOG_FILE"
echo "Retry Iterations: $RETRY_ITERATIONS" | tee -a "$LOG_FILE"
echo "Errors Resolved: $ERRORS_RESOLVED" | tee -a "$LOG_FILE"
echo "Error Types Learned: $ERROR_TYPES_LEARNED" | tee -a "$LOG_FILE"
echo "" | tee -a "$LOG_FILE"
echo "Report: $REPORT_FILE" | tee -a "$LOG_FILE"
echo "Main Log: $LOG_FILE" | tee -a "$LOG_FILE"
echo "Retry Loop Logs: $RETRY_LOOP_DIR" | tee -a "$LOG_FILE"
echo "Error Database: $ERROR_DB_FILE" | tee -a "$LOG_FILE"
echo "Command History: $COMMAND_HISTORY_FILE" | tee -a "$LOG_FILE"

exit $FINAL_EXIT_CODE
```

## Caratteristiche Sistema Error Retry Loop

### Loop Retry Infinito con Machine Learning
- **Nessun limite tentativi**: Continua fino a risoluzione completa
- **Hidden error detection**: Analisi log per errori nascosti anche con exit code 0
- **Error classification**: 9 categorie errore con recovery specifici
- **Smart backoff**: Backoff adattivo basato su storia successi comando

### Analisi Log Avanzata
- **Pattern recognition**: 10+ pattern errori nascosti in log
- **Critical warning detection**: Identifica warning che potrebbero essere critici
- **Performance issue tracking**: Monitora problemi performance
- **Error learning database**: JSON database per machine learning

### Recovery Intelligente per Advanced Features
- **Video processing**: Recovery specifico per FFmpeg e media processing
- **Network issues**: Restart servizi rete con DNS fixes
- **Memory management**: GC tuning e cache clearing
- **Docker management**: Container restart e cleanup automatico

Il sistema garantisce che ogni comando delle advanced features (video, real-time, PWA) venga eseguito fino al successo attraverso retry loop continuo con apprendimento automatico dei pattern di errore.